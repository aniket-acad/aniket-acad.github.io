<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Multi-dimensional Arrays</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta keywords="">
<style>

.CodeMirror {
  height: inherit;
}

.doc-embed {
  padding: 0;
  border: 1px solid #D2D3D6;
  border-radius: 3px;
  margin-bottom: 8px;

  color: #45474B;

  .doc-embed-wrapper {
    display: flex;
    align-items: stretch;
    flex-wrap: nowrap;
  }

  .collapse-trigger {
    flex: 0 0 auto;
    display: flex;
    flex-direction: column;
    padding-top: 4px;
    padding-left: 4px;
    cursor: pointer;
    overflow: hidden;

    .threadline {
      flex: 1 1 auto;
      width: 1px;
      background: #EDEDEE;
      transition: 0.2s
      display: block;
      margin: auto;
    }

    &:hover .threadline {
      width: 1px;
      background: #2C2D30
    }
  }

  svg {
    width: 40px;
    height: 40px;
    cursor: pointer;
    fill: currentColor;
  }

  &.collapsed {
    .collapse-trigger  {
      .threadline {
        display: none;
      }
      svg {
        transform: rotate(-90deg);
      }
    }
    .doc-embed-content {
      display: none;
    }
  }

  .embed-body {
    min-width: 0;
  }

  .doc-embed-header {
    display: flex;
    align-items: center;

    & > div {
      flex: 1;
      min-width: 0;
      padding: 8px 16px 8px 4px;
    }

    h1, a {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    h1 {
      font-size: 24px;
      margin: 0;
    }

    p {
      margin: 0;
    }

    a {
      display: block;
    }

    a > svg {
      margin-right: 5px;
      width: 20px;
      height: 20px;
      vertical-align: middle;
    }
  }

  .doc-embed-content {
    padding: 0 16px;
  }
}

-ms-text-size-adjust: 100%;
-webkit-text-size-adjust: 100%;
line-height: 1.6;
font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial,
  sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol;
font-size: 16px;
line-height: 1.6;
word-wrap: break-word;

.dark, .solarizedDark {
  color: #FFF;
}

details {
  display: block;
}

summary {
  display: list-item;
}

a {
  background-color: transparent;
}

a:active,
a:hover {
  outline-width: 0;
}

strong {
  font-weight: inherit;
  font-weight: bolder;
}

h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

img {
  border-style: none;
}

code,
kbd,
pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

input {
  font: inherit;
  margin: 0;
}

input {
  overflow: visible;
}

[type='checkbox'] {
  box-sizing: border-box;
  padding: 0;
}

* {
  box-sizing: border-box;
}

input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

a {
  color: #0366d6;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

strong {
  font-weight: 600;
}

hr {
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
  height: 0;
  margin: 15px 0;
  overflow: hidden;
}

hr:before {
  content: '';
  display: table;
}

hr:after {
  clear: both;
  content: '';
  display: table;
}

table {
  border-collapse: collapse;
  border-spacing: 0;
}

td,
th {
  padding: 0;
}

details summary {
  cursor: pointer;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  margin-bottom: 0;
  margin-top: 0;
}

h1 {
  font-size: 32px;
}

h1,
h2 {
  font-weight: 500;
}

h2 {
  font-size: 24px;
}

h3 {
  font-size: 20px;
}

h3,
h4 {
  font-weight: 500;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h5,
h6 {
  font-weight: 600;
}

h6 {
  font-size: 12px;
}

p {
  margin-bottom: 10px;
  margin-top: 0;
}

blockquote {
  margin: 0;
}

ol,
ul {
  margin-bottom: 0;
  margin-top: 0;
  padding-left: 0;
}

ol ol,
ul ol {
  list-style-type: lower-roman;
}

ol ol ol,
ol ul ol,
ul ol ol,
ul ul ol {
  list-style-type: lower-alpha;
}

dd {
  margin-left: 0;
}

code,
pre {
  font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier,
    monospace;
  font-size: 12px;
}

pre.CodeMirror,
code.CodeMirror {
  height: auto;
}

pre {
  margin-bottom: 0;
  margin-top: 0;
}

input::-webkit-inner-spin-button,
input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

&:before {
  content: '';
  display: table;
}

&:after {
  clear: both;
  content: '';
  display: table;
}

> :first-child {
  margin-top: 0 !important;
}

> :last-child {
  margin-bottom: 0 !important;
}

a:not([href]) {
  color: inherit;
  text-decoration: none;
}

blockquote,
dl,
ol,
p,
pre,
table,
ul {
  margin-bottom: 16px;
  margin-top: 0;
}

hr {
  background-color: #e1e4e8;
  border: 0;
  height: 1px;
  margin: 16px 0;
  padding: 0;
}

blockquote {
  border-left: 0.25em solid #e1e4e8;
  color: #999999;
  padding: 0 1em;
}

blockquote > :first-child {
  margin-top: 0;
}

blockquote > :last-child {
  margin-bottom: 0;
}

kbd {
  background-color: #fafbfc;
  border: 1px solid #c6cbd1;
  border-bottom-color: #959da5;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #959da5;
  color: #444d56;
  display: inline-block;
  font-size: 11px;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  line-height: 1.25;
  margin: 8px 0;
}

h1 {
  margin-top: 32px;
  font-weight: 600;
  font-size: 1.953em;
  margin-bottom: 10px;
}

h2 {
  font-weight: 600;
  font-size: 1.5em;
  margin-top: 16px;
  margin-bottom: 8px;
}

h3 {
  font-weight: 600;
  font-size: 1.25em;
}

h4 {
  font-weight: 400;
  font-size: 1em;
}

h5 {
  font-weight: 400;
  font-size: 0.875em;
}

h6 {
  font-weight: 400;
  color: #6a737d;
  font-size: 0.85em;
}

ol,
ul {
  padding-left: 2em;
}
ol ol,
ol ul,
ul ol,
ul ul {
  margin-bottom: 0;
  margin-top: 0;
}

li {
  word-wrap: break-all;
}

li > p {
  margin-top: 16px;

  &:first-child {
    margin-top: 0;
  }
  &:last-child {
    margin-bottom: 0;
  }
}

li + li {
  margin-top: 0.25em;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
  margin-top: 16px;
  padding: 0;
}

dl dd {
  margin-bottom: 16px;
  padding: 0 16px;
}

table {
  display: block;
  overflow: auto;
  width: 100%;
}

table th {
  font-weight: 600;
}

table td,
table th {
  border: 1px solid #dfe2e5;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #c6cbd1;
}

img {
  display: block;
  max-width: 100%;
  height: auto;
  margin: 15px 0;
  box-sizing: content-box;
}

img[align='right'] {
  padding-left: 20px;
}

img[align='left'] {
  padding-right: 20px;
}

code {
  background-color: rgba(27, 31, 35, 0.05);
  border-radius: 3px;
  font-size: 85%;
  margin: 0;
  padding: 0.2em 0.4em;
}

p code,
li code
{
  padding: 2px;
  border-width: 1px;
  border-style: solid;
  border-radius: 5px;
}

pre {
  word-wrap: normal;
}

pre > code {
  background: transparent;
  border: 0;
  font-size: 100%;
  margin: 0;
  padding: 0;
  white-space: pre;
  word-break: normal;
}

.highlight {
  margin-bottom: 16px;
}

.highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.highlight pre,
pre {
  background-color: #f6f8fa;
  border-radius: 3px;
  font-size: 85%;
  line-height: 1.45;
  overflow: auto;
  padding: 16px;
}

pre code {
  background-color: transparent;
  border: 0;
  display: inline;
  line-height: inherit;
  margin: 0;
  max-width: auto;
  overflow: visible;
  padding: 0;
  word-wrap: normal;
}

kbd {
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-bottom-color: #c6cbd1;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #c6cbd1;
  color: #444d56;
  display: inline-block;
  font: 11px SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier,
    monospace;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

:checked + .radio-label {
  border-color: #0366d6;
  position: relative;
  z-index: 1;
}

.task-list-item {
  position: relative;
  list-style-type: none;
  height: fit-content;
  min-height: 25px;
}

.task-list-item + .task-list-item {
  margin-top: 3px;
}

.task-list-item input {
  margin: 0 0.2em 0.25em -1.6em;
  vertical-align: middle;
}

.task-list-item input[type=checkbox] {
  position: absolute;
  top: 6px;
}

hr {
  border-bottom-color: #eee;
}

.dark p code,
.dark li code
{
  background-color: rgba(255,255,255,0.12);
  border-color: rgba(255,255,255,0.3);
  color: #5580DC;
}

.auto p code,
.auto li code
{
  background-color: #F9F9F9;
  border-color: rgba(0,0,0,0.26);
  color: #5580DC;
}

.light p code,
.light li code
{
  background-color: #F9F9F9;
  border-color: rgba(0,0,0,0.26);
  color: #5580DC;
}

.sepia p code,
.sepia li code
{
  background-color: #efe8d6;
  border-color: rgba(0,0,0,0.26);
  color: #F77942;
}

.solarizedDark p code,
.solarizedDark li code
{
  background-color: rgba(255,255,255,0.12);
  border-color: rgba(255,255,255,0.3);
  color: #36abe3;
}
  
   #colorstrip{
    width: 100%; height: 2px;
    border-style: solid;
    border-color: grey;
    background-color: grey;
}
  
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
</head>
<body>
<h2>Multi-dimensional Array Data Structure</h2>
<h4>CSL 102; Data Structures; IIIT Nagpur; Created by Dr. Aniket Pingley</h4><br>
<p><strong>Ordering of Main memory</strong></p>
<p>Imagine a matrix or a grid. It has certain number of rows and columns. Elements in a matrix like structure can be accessed by indexing with a combination of row and column. For example, M[i][j] enables access of single element in matrix M where <em>i</em> is the row number and <em>j</em> is the column number.</p>
<p>In the domain of computing, many applications require matrix-like structuring of data. For example, an image is represented as a matrix in memory. A matrix is implemented using two dimensional arrays in C language.</p>
<p>So far we have worked with arrays that have single indexing. This is similar to having a matrix with a single row and multiple columns. Main memory occupies a linear address space. Thus, it can be treated as a very large, single dimensional array. If our program has a two-dimensional array (or higher) then the compiler maps it into single dimension of main memory for storage. Two ways to achieve this are row major order and column major order - the former being the most commonly used.</p>
<p><img src="images/2338b6ad-240d-4b79-999a-c13690994f58.png" width="40%" height="40%"></p>

<hr>
<p><strong>Two-dimensional arrays</strong></p>
<p>Typically programmers deal with arrays that have single dimension, which translates to array data structure that has a single row and multiple columns. Intuitively, each value of single dimensional array is located at a different column. When an array data structure has multiple rows along with multiple columns, it becomes two-dimensional. The number of rows and columns need not be same. For R rows and C columns, the indexing of the two dimensional array will range from 0 to R-1 and 0 to C-1.</p>
<pre class="cm-s-default CodeMirror"><code>
  
  #define ROWS 3
  #define COLUMNS 4
  
  int main(){
      /*
      The general pattern for declaration of 2d array:
      data_type var_name[num_rows][num_columns] where 
          - data_type is a valid data type in C language
          - var_name is the name of the variable
      */
      int twoD_arr[ROWS][COLUMNS]; /* declaration without initialization*/
  
      /*Initialization*/
      /*First row: values 0 through 3*/
      /*Second row: values 4 through 7*/
      /*Third row: values 8 through 11*/
      int twoD_arr2[ROWS][COLUMNS] = {0,1,2,3,4,5,6,7,8,9,10,11}; 
  
      /*Clearer way to initialize*/
      int twoD_arr3[ROWS][COLUMNS] = {{0,1,2,3}, {4,5,6,7}, {8,9,10,11}};
  
      /*Accessing the elements in two dimensional array*/
      for (short i = 0; i < ROWS; i++){
          for (short j = 0; j < COLUMNS; j++){
              printf("twoD_arr3[%d][%d] = %d\n", i, j, twoD_arr3[i][j]);
          }
      }
  
      return 0;
  }
</code></pre> 

<hr>
<p><strong>Three-dimensional arrays</strong></p>
<p>A three dimensional array can be visualized a series of two dimensional arrays as shown in the image below.</p>
<p><img src="images/bf85437d-aee3-4eff-a2f9-83282a89104e.jpeg" width="40%" height="40%"></p>
<p><em>Image source: Geeks for Geeks</em></p>

<pre class="cm-s-default CodeMirror"><code>
  /*Assume the preprocessor directive #define DEPTH 3*/
  /*series of 3 two dimensional arrays*/
    int threeD_arr3[DEPTH][ROWS][COLUMNS] = {
        {{0,1,2,3}, {4,5,6,7}, {8,9,10,11}},
        {{0,-1,-2,-3}, {-4,-5,-6,-7}, {-8,-9,-10,-11}},
        {{2,4,6,8}, {-2,-4,-6,-8}, {12,13,14,15}}
        };

    for (short i = 0; i < DEPTH; i++){
        for (short j = 0; j < ROWS; j++){
            for (short k = 0; k < COLUMNS; k++){
                printf("threeD_arr3[%d][%d][%d] = %d\n", i,j,k, threeD_arr3[i][j][k]);
            }
        }
    }
</code></pre>
  
<hr>
<p><strong>Calculating the index values & addresses for 2D and 3D arrays</strong></p>
<p>Since multidimensional arrays are implemented using contiguous memory locations, a simple arithmetic formula can be devised for calculating the single dimensional index for a given set of depth, rows and columns. Consider the following:
<ul>
<li>D = total depth</li>
<li>R = total rows</li>
<li>C = total columns</li>
<li>S = starting address of the array</li>
<li>Z = size of data type of array in bytes</li>
<li><em>d</em> = current depth (range 0 to D-1)</li>
<li><em>r</em> = current row (range 0 to R-1)</li>
<li><em>c</em> = current column (range 0 to C-1)</li>
</ul>
<p><em>arr2[R][C]</em> is a two dimensional array. <em>arr3[D][R][C]</em> is a three dimensional array. Assuming row-major order: </p>
<ul>
  <li>For a given lookup operation arr2[r][c], index = <em>r</em> * C + c</li>
  <li>For a given lookup operation arr2[r][c], address = S + Z * (<em>r</em> * C + c)</li>
  <li>For a given lookup operation arr3[d][r][c], index = <em>d</em> * R * C + <em>r</em> * C +  c</li>
  <li>For a given lookup operation arr3[d][r][c], address = S + Z * (<em>d</em> * R * C + <em>r</em> * C +  c)</li>
</ul>
</p>
<p>
It must be noted that while performing lookup operation in C language using pointers, the size of data type (Z, above) must not be used. Pointer arithmetic will increment or decrement the addresses based on the type of data that the pointer points. For example, adding 1 to int* will increment the address by 4 bytes. However, adding 1 to char* increments the address by 1 byte. The code snippet below will make it amply clear. 
</p>  
  
  
<pre class="cm-s-default CodeMirror"><code>
  
  int main()
  {
    int a[10] = {0};
    char s[] = "qwertyuiop";
    int *r = a;
    char *t = s;
    printf("%p, %p\n", r, r+1);
    printf("%p, %p\n", t, t+1);

    return 0;
  }
  </code></pre>
  
<br>
<div id="colorstrip"/> 
<br><br>
<a href="../csl102.html">HOME</a>&nbsp;&nbsp;&nbsp;<a href="arrays.html">PREV</a>&nbsp;&nbsp;&nbsp;<a href="searching.html">NEXT</a>  
<br><br>
<div id="colorstrip"/>
<br>  
  
</body>
</html>
